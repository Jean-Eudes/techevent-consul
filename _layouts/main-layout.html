<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Techevent-consul by Jean-Eudes</title>
    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="../javascripts/script.js"></script>

    <script src="../javascripts/respond.js"></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="../stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

</head>

<body>
<div id="header">
    <nav>
        <li class="fork"><a href="https://github.com/Jean-Eudes/techevent-consul">View On GitHub</a></li>
        <li class="downloads"><a href="https://github.com/Jean-Eudes/techevent-consul/zipball/master">ZIP</a></li>
        <li class="downloads"><a href="https://github.com/Jean-Eudes/techevent-consul/tarball/master">TAR</a></li>
        <li class="title">DOWNLOADS</li>
    </nav>
</div><!-- end header -->

<div class="wrapper">

    <section id="main-content">
        <h2>Workshop : Service discovery &amp; Consul
        </h2>


        <p>Dans ce workshop, vous aurez à disposition 4 instances :
        <ul>
            <li>1 instance de consul en mode server</li>
            <li>2 instances contenant 2 service web</li>
            <li>1 instance servant à répartir la charge entre les deux instances de service web</li>
        </ul>

        Le but de ce workshop est d'utiliser consul pour enregister la configuration de vos services, puis d'utiliser cette configuration
        afin de générer la configuration d'un load balancer : ceci permettra à votre application de scaler de manière automatique.

    </section>

    <section>
        Consul est un outil de service discovery, permettant à des services de s'enregistrer auprès d'un serveur, et à d'autres services d'interroger ce même serveur pour récupérer des informations sur les services déployés sur notre cluster.

        <h2>Introduction</h2>

        Il y a quelques mois, votre entreprise a suivi le dernier buzz word à la mode suite à une université à devoxx france, et à décider de se lancer dans l’aventure des micro services. De très nombreux micro services plus tard, un problème est apparu : comment connaître l’adresse de mes services. Après consultation du pôle architecture de notre société, suivi par de trop nombreuses réunions, il a été décidé de mettre en place une solution de service discovery.

        <h2>Connection aux machines</h2>


        <p>Pour vous connecter aux machines : </p>

        {% highlight bash %}
$ ssh consul@{{page.group}}-server.consul.aws.xebiatechevent.info
        {% endhighlight %}  

       <h2>Installation de consul (étape déjà faite pour ce techevent)</h2>

        Consul est livré sous la forme d’un simple binaire. Il suffit simplement de le télécharger :

        {% highlight bash %}
$ wget https://dl.bintray.com/mitchellh/consul/0.6.4_linux_amd64.zip
        {% endhighlight %}

    </section>

    <section>
        <h1>Lancement du serveur consul</h1>

        Nous allons maintenant lancer notre serveur consul, en spécifiant que nous ne lançons que une instance (pas de redondance), et qu’il sera accessible depuis l’extérieur.

       lancer le serveur :
        {% highlight bash %}
$ consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=serveur1 --client 0.0.0.0 -ui -config-dir /etc/consul.d  > log &
        {% endhighlight %}

        Il est possible de regarder l’état du serveur avec la commande

        {% highlight bash %}
$ consul members
        {% endhighlight %}

    </section>

    <section>
        <h1>Lancement de l'agent consul</h1>

        On va maintenant ajouter un agent consul et le connecter à notre serveur. Connectez vous à votre machine web1, et lancer l'agent consul

        {% highlight bash %}
$ ssh consul@{{page.group}}-web1.consul.aws.xebiatechevent.info
        {% endhighlight %}


        {% highlight bash %}
$ consul agent -data-dir /tmp/consul -node=agent1 -config-dir /etc/consul.d > log &
$ consul join <addr_ip_privé_serveur_consul/>
        {% endhighlight %}

        Si vous demandez maintenant à consul de vous affichez l’état du cluster, vous verrez bien apparaître deux lignes, une pour le serveur, et une pour le client.

        Consul propose également une api rest pour connaître l’état du cluster

        {% highlight bash %}
$ curl localhost:8500/v1/catalog/nodes
        {% endhighlight %}


        Il est également possible de voir l’état du cluster en se connectant à l’interface web :

         <p>
        <a href="http://{{page.group}}-server.consul.aws.xebiatechevent.info:8500/ui/"> http://{{page.group}}-server.consul.aws.xebiatechevent.info:8500/ui/</a>
         </p>
    </section>

    <section>
        <h1>Création de notre premier service</h1>

Avec consul, la création d’un service passe par la création d’un fichier json décrivant le service. Dans le répertoire <em>/etc/consul.d</em> de la machine {{page.group}}-web1.consul.aws.xebiatechevent.info, créer un fichier nommé web.json avec le contenu suivant :

{% highlight javascript %}
{"service":
    {
        "name": "web",
        "tags": ["web"], "port": 8000
    }
}
{% endhighlight %}

        Ici, nous avons déclaré à consul qu'il existe sur ce serveur un service nommé web et exposé sur le port 8000.

Lancer ensuite la commande consul reload pour demander à l'agent consul de recharger la configuration.

{% highlight bash %}
$ consul reload
{% endhighlight %}

Vous pouvez voir dans l’interface qu'un nouveau service est apparu.

    </section>

    <section>
        <h1>Interroger consul</h1>
Consul met à disposition deux interfaces pour avoir accès aux informations d’un service :
        <ul>
<li>un service REST</li>
<li>un serveur DNS.</li>
        </ul>
Essayer de récupérer les informations de votre service avec les deux interfaces disponibles.

<a href="https://www.consul.io/docs/agent/http/catalog.html">lien vers la documentation de l'api REST</a>

<a href = "https://www.consul.io/docs/agent/dns.html">lien vers la documentation de l'interface DNS</a>

        Vous pouvez utiliser curl comme client http et dig comme client dns.

<div class = 'solution'>
{% highlight bash %}
$ curl localhost:8500/v1/health/service/web
$ dig @127.0.0.1 -p 8600 web.service.consul
{% endhighlight %}
</div>

Remarque : Consul est aussi capable d'utiliser le protocole DNS SRV, qui permet notamment d’accéder en plus de l’adresse IP au port du serveur demandé :

<div class = 'solution'>
{% highlight bash %}
$ dig @127.0.0.1 -p 8600 web.service.consul SRV
{% endhighlight %}
</div>

    </section>

    <section>
        <h1>Gestion du health check</h1>

        <h2>Au niveau du service</h2>

        Il est possible de rajouter un health check pour déterminer si notre service est up ou non. Modifier le fichier web.json pour rajouter une gestion du health check pour vérifier que le service répond en GET sur son port d'écoute.

        N'oubliez pas de recharger la configuration.

        <a href="https://www.consul.io/docs/agent/checks.html">lien vers la documentation du health check</a>

        <div class = 'solution'>
{% highlight javascript %}
{"service":
    {"name": "web",
        "tags": ["web"],
        "port": 8000,
        "check": {
            "script": "curl -f -X GET http://localhost:8000",
            "interval": "30s"
        }
    }
}
{% endhighlight %}
        </div>

        Essayer ensuite de demander au serveur DNS fourni par consul l’adresse de notre service <em>web</em>. Comme le health check lui indique que le service est KO, il ne renvoie pas l'adresse IP.
        Vous pouvez fixer en lancer un simple serveur http.

        {% highlight bash %}
$ python -m SimpleHTTPServer &
        {% endhighlight %}

        Vous pouvez de nouveaux accéder aux services. Sur l’interface web, des compléments d’informations nous sont fournis sur les résultats du health check.

    </section>


<section>
    <h1>Configuration du HAproxy</h1>

    On va maintenant générer la configuration de notre HAproxy à partir des informations contenu dans <em>consul</em>. Le serveur HAproxy sera en frontal
    de notre service <em>web</em>.

    Dans l'écosystème consul, il existe un outil appelé <em>consul-template</em> qui permet de générer un fichier à partir des informations contenues dans consul.
    consul-template regénère ce fichier si la configuration change dans consul, et peut également lancer une commande (par exemple un reload de haproxy).

    Les fichiers template gérés par consul se base sur la syntaxe <a href="https://github.com/hashicorp/hcl">hcl</a>. En vous basant sur l'exemple suivant,
    créer un fichier template (haproxy.tmpl) qui génère une configuration haproxy renvoyant les requêtes vers notre service <em>web</em>.

    {% highlight bash %}
$ ssh consul@{{page.group}}-balancer.consul.aws.xebiatechevent.info
    {% endhighlight %}


    Exemple de configuration HAproxy :

    {% highlight text %}
global
  daemon
  maxconn 256

defaults
  mode http
  timeout connect 5000ms
  timeout client 50000ms
  timeout server 50000ms

listen http-in
  bind *:8000
  server web1 127.0.0.1:8000
    {% endhighlight %}


    Pour lancer consul-template, utlisez la commande ci-dessous.

    {% highlight bash %}
$ consul-template -consul <address_serveur_consul/>:8500 -template "haproxy.tmpl:haproxy.conf" &
    {% endhighlight %}

    <a href="https://github.com/hashicorp/consul-template">lien vers la documentation de consul-template</a>

    <div class = 'solution'>
        {% highlight ruby %}
global
  daemon
  maxconn 256

defaults
  mode http
  timeout connect 5000ms
  timeout client 50000ms
  timeout server 50000ms

listen http-in
  bind *:8000
        {{ "{{ range service 'web' "}} }}
  server {{ "{{ .Node "}} }} {{ "{{.Address "}} }} : {{ "{{ .Port "}} }}
        {{ "{{ end "}} }}
        {% endhighlight %}
    </div>

    Eteigner votre serveur python, et regarder le fichier haproxy.conf se mettre à jour.

</section>


    <section>
        <h1>Scaling automatique de notre service</h1>

        On va maintenant ajouter un deuxième service <em>web</em> sur la machine web2, et l'enregistrer auprès de consul. Pour celà, connectez vous sur la machine web2, installer le client consul, et enregistrer un deuxième service <em>web</em>.

        <div class = 'solution'>

        {% highlight bash %}
$ ssh consul@{{page.group}}-web2.consul.aws.xebiatechevent.info
$ consul agent -data-dir /tmp/consul -node=agent1 -config-dir /etc/consul.d > log &
$ consul join <addr_ip_privé_serveur_consul/>
$ echo -e "{"service": { "name": "web", "tags": ["web2"], "port": 8000} }" > /etc/consul.d/web2.json
$ consul reload
        {% endhighlight %}
            </div>

        On remarque que la configuration du fichier haproxy se met automatiquement à jour, et que le fichier contient maintenant deux lignes.

    </section>

    <section>
        <h1>Base de donnée clefs valeurs</h1>

        Consul possède également une base de données clef valeur lui permettant de stocker des informations qui pourront par la suite être accessible par exemple par les applications via l’API http.

        A l’aide de l’API http, renseignez les cinq clefs suivantes avec leurs valeurs associées :

        {% highlight text %}
service/haproxy/maxconn : 256
service/haproxy/timeout/connect : 5000ms
service/haproxy/timeout/client : 50000ms
service/haproxy/timeout/server : 50000ms
service/haproxy/mode : http
        {% endhighlight %}

        <a href="https://www.consul.io/intro/getting-started/kv.html">lien vers la documentation du key value store de consul</a>

        <div class = 'solution'>
            {% highlight bash %}
$ curl -X PUT -d '256' http://localhost:8500/v1/kv/service/haproxy/maxconn
$ curl -X PUT -d '5000ms' http://localhost:8500/v1/kv/service/haproxy/timeout/connect
$ curl -X PUT -d '50000ms' http://localhost:8500/v1/kv/service/haproxy/timeout/client
$ curl -X PUT -d '50000ms' http://localhost:8500/v1/kv/service/haproxy/timeout/server
$ curl -X PUT -d 'http' http://localhost:8500/v1/kv/service/haproxy/mode
            {% endhighlight %}
        </div>

        Connectez vous ensuite sur la machine balancer, et modifiez la configuration du template haproxy pour utiliser ces valeurs dans la
        configuration HAproxy.

    </section>

    <section>
        <h1>Ajout d'un health check au niveau du node</h1>

        Il est aussi possible de rajouter un health check au niveau du node. Consul va considérer que si le health check d'un node renvoie une erreur, alors tous les services déployés sur ce node sont considérés comme inaccessible.

        On va rajouter un check simple qui permet de visualiser la consommation mémoire de notre agent. Pour celà, on va créer dans notre répertoire bin un fichier mem.sh contenant le script suivant :

        {% highlight bash %}
$ free -m | awk 'NR==2{printf "Memory Usage: %s/%sMB (%.2f%%)\n", $3,$2,$3*100/$2 }'
        {% endhighlight %}

        Penser à rajouter les droits d'exécution sur ce fichier.

        Ensuite, dans le répertoire de travail consul, créer un fichier nommé memcheck.json permettant à consul de nous afficher sur l’ui la mémoire utilisé sur votre machine.

        <div class = 'solution'>
            {% highlight javascript %}
{"check":
    {"name": "memory check",
        "script": "$HOME/bin/mem.sh",
        "interval": "30s"
    }
}
            {% endhighlight %}
        </div>

        Remarque : le code de retour du script va indiquer si le service est up ou non

        Vous pouvez vous amusez à faire de même pour vérifier l’utilisation disque de la machine et le load average avec les scripts suivants :

        {% highlight bash %}
$ df -h | awk '$NF=="/"{printf "Disk Usage: %d/%dGB (%s)\n", $3,$2,$5}'
$ cat /proc/loadavg | awk '{printf "CPU Load Average: 1m: %.2f, 5m: %.2f, 15m: %.2f\n", $1,$2,$3}'
        {% endhighlight %}

    </section>


</div>
<!--[if !IE]><script>fixScale(document);</script><![endif]-->

</body>


</html>
